(->
  b2ControllerEdge = Box2D.Dynamics.Controllers.b2ControllerEdge
  b2Mat22 = Box2D.Common.Math.b2Mat22
  b2Mat33 = Box2D.Common.Math.b2Mat33
  b2Math = Box2D.Common.Math.b2Math
  b2Sweep = Box2D.Common.Math.b2Sweep
  b2Transform = Box2D.Common.Math.b2Transform
  b2Vec2 = Box2D.Common.Math.b2Vec2
  b2Vec3 = Box2D.Common.Math.b2Vec3
  b2Color = Box2D.Common.b2Color
  b2internal = Box2D.Common.b2internal
  b2Settings = Box2D.Common.b2Settings
  b2AABB = Box2D.Collision.b2AABB
  b2Bound = Box2D.Collision.b2Bound
  b2BoundValues = Box2D.Collision.b2BoundValues
  b2Collision = Box2D.Collision.b2Collision
  b2ContactID = Box2D.Collision.b2ContactID
  b2ContactPoint = Box2D.Collision.b2ContactPoint
  b2Distance = Box2D.Collision.b2Distance
  b2DistanceInput = Box2D.Collision.b2DistanceInput
  b2DistanceOutput = Box2D.Collision.b2DistanceOutput
  b2DistanceProxy = Box2D.Collision.b2DistanceProxy
  b2DynamicTree = Box2D.Collision.b2DynamicTree
  b2DynamicTreeBroadPhase = Box2D.Collision.b2DynamicTreeBroadPhase
  b2DynamicTreeNode = Box2D.Collision.b2DynamicTreeNode
  b2DynamicTreePair = Box2D.Collision.b2DynamicTreePair
  b2Manifold = Box2D.Collision.b2Manifold
  b2ManifoldPoint = Box2D.Collision.b2ManifoldPoint
  b2Point = Box2D.Collision.b2Point
  b2RayCastInput = Box2D.Collision.b2RayCastInput
  b2RayCastOutput = Box2D.Collision.b2RayCastOutput
  b2Segment = Box2D.Collision.b2Segment
  b2SeparationFunction = Box2D.Collision.b2SeparationFunction
  b2Simplex = Box2D.Collision.b2Simplex
  b2SimplexCache = Box2D.Collision.b2SimplexCache
  b2SimplexVertex = Box2D.Collision.b2SimplexVertex
  b2TimeOfImpact = Box2D.Collision.b2TimeOfImpact
  b2TOIInput = Box2D.Collision.b2TOIInput
  b2WorldManifold = Box2D.Collision.b2WorldManifold
  ClipVertex = Box2D.Collision.ClipVertex
  Features = Box2D.Collision.Features
  IBroadPhase = Box2D.Collision.IBroadPhase
  b2CircleShape = Box2D.Collision.Shapes.b2CircleShape
  b2EdgeChainDef = Box2D.Collision.Shapes.b2EdgeChainDef
  b2EdgeShape = Box2D.Collision.Shapes.b2EdgeShape
  b2MassData = Box2D.Collision.Shapes.b2MassData
  b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape
  b2Shape = Box2D.Collision.Shapes.b2Shape
  b2Body = Box2D.Dynamics.b2Body
  b2BodyDef = Box2D.Dynamics.b2BodyDef
  b2ContactFilter = Box2D.Dynamics.b2ContactFilter
  b2ContactImpulse = Box2D.Dynamics.b2ContactImpulse
  b2ContactListener = Box2D.Dynamics.b2ContactListener
  b2ContactManager = Box2D.Dynamics.b2ContactManager
  b2DebugDraw = Box2D.Dynamics.b2DebugDraw
  b2DestructionListener = Box2D.Dynamics.b2DestructionListener
  b2FilterData = Box2D.Dynamics.b2FilterData
  b2Fixture = Box2D.Dynamics.b2Fixture
  b2FixtureDef = Box2D.Dynamics.b2FixtureDef
  b2Island = Box2D.Dynamics.b2Island
  b2TimeStep = Box2D.Dynamics.b2TimeStep
  b2World = Box2D.Dynamics.b2World
  b2CircleContact = Box2D.Dynamics.Contacts.b2CircleContact
  b2Contact = Box2D.Dynamics.Contacts.b2Contact
  b2ContactConstraint = Box2D.Dynamics.Contacts.b2ContactConstraint
  b2ContactConstraintPoint = Box2D.Dynamics.Contacts.b2ContactConstraintPoint
  b2ContactEdge = Box2D.Dynamics.Contacts.b2ContactEdge
  b2ContactFactory = Box2D.Dynamics.Contacts.b2ContactFactory
  b2ContactRegister = Box2D.Dynamics.Contacts.b2ContactRegister
  b2ContactResult = Box2D.Dynamics.Contacts.b2ContactResult
  b2ContactSolver = Box2D.Dynamics.Contacts.b2ContactSolver
  b2EdgeAndCircleContact = Box2D.Dynamics.Contacts.b2EdgeAndCircleContact
  b2NullContact = Box2D.Dynamics.Contacts.b2NullContact
  b2PolyAndCircleContact = Box2D.Dynamics.Contacts.b2PolyAndCircleContact
  b2PolyAndEdgeContact = Box2D.Dynamics.Contacts.b2PolyAndEdgeContact
  b2PolygonContact = Box2D.Dynamics.Contacts.b2PolygonContact
  b2PositionSolverManifold = Box2D.Dynamics.Contacts.b2PositionSolverManifold
  b2Controller = Box2D.Dynamics.Controllers.b2Controller
  b2DistanceJoint = Box2D.Dynamics.Joints.b2DistanceJoint
  b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef
  b2FrictionJoint = Box2D.Dynamics.Joints.b2FrictionJoint
  b2FrictionJointDef = Box2D.Dynamics.Joints.b2FrictionJointDef
  b2GearJoint = Box2D.Dynamics.Joints.b2GearJoint
  b2GearJointDef = Box2D.Dynamics.Joints.b2GearJointDef
  b2Jacobian = Box2D.Dynamics.Joints.b2Jacobian
  b2Joint = Box2D.Dynamics.Joints.b2Joint
  b2JointDef = Box2D.Dynamics.Joints.b2JointDef
  b2JointEdge = Box2D.Dynamics.Joints.b2JointEdge
  b2LineJoint = Box2D.Dynamics.Joints.b2LineJoint
  b2LineJointDef = Box2D.Dynamics.Joints.b2LineJointDef
  b2MouseJoint = Box2D.Dynamics.Joints.b2MouseJoint
  b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef
  b2PrismaticJoint = Box2D.Dynamics.Joints.b2PrismaticJoint
  b2PrismaticJointDef = Box2D.Dynamics.Joints.b2PrismaticJointDef
  b2PulleyJoint = Box2D.Dynamics.Joints.b2PulleyJoint
  b2PulleyJointDef = Box2D.Dynamics.Joints.b2PulleyJointDef
  b2RevoluteJoint = Box2D.Dynamics.Joints.b2RevoluteJoint
  b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef
  b2WeldJoint = Box2D.Dynamics.Joints.b2WeldJoint
  b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef
  b2Body.b2Body = ->
    @m_xf = new b2Transform()
    @m_sweep = new b2Sweep()
    @m_linearVelocity = new b2Vec2()
    @m_force = new b2Vec2()
    return

  b2Body::connectEdges = (s1, s2, angle1) ->
    angle1 = 0  if angle1 is `undefined`
    angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x)
    coreOffset = Math.tan((angle2 - angle1) * 0.5)
    core = b2Math.MulFV(coreOffset, s2.GetDirectionVector())
    core = b2Math.SubtractVV(core, s2.GetNormalVector())
    core = b2Math.MulFV(b2Settings.b2_toiSlop, core)
    core = b2Math.AddVV(core, s2.GetVertex1())
    cornerDir = b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector())
    cornerDir.Normalize()
    convex = b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0
    s1.SetNextEdge s2, core, cornerDir, convex
    s2.SetPrevEdge s1, core, cornerDir, convex
    angle2

  b2Body::CreateFixture = (def) ->
    return null  if @m_world.IsLocked() is true
    fixture = new b2Fixture()
    fixture.Create this, @m_xf, def
    if @m_flags & b2Body.e_activeFlag
      broadPhase = @m_world.m_contactManager.m_broadPhase
      fixture.CreateProxy broadPhase, @m_xf
    fixture.m_next = @m_fixtureList
    @m_fixtureList = fixture
    ++@m_fixtureCount
    fixture.m_body = this
    @ResetMassData()  if fixture.m_density > 0.0
    @m_world.m_flags |= b2World.e_newFixture
    fixture

  b2Body::CreateFixture2 = (shape, density) ->
    density = 0.0  if density is `undefined`
    def = new b2FixtureDef()
    def.shape = shape
    def.density = density
    @CreateFixture def

  b2Body::DestroyFixture = (fixture) ->
    return  if @m_world.IsLocked() is true
    node = @m_fixtureList
    ppF = null
    found = false
    while node?
      if node is fixture
        if ppF
          ppF.m_next = fixture.m_next
        else
          @m_fixtureList = fixture.m_next
        found = true
        break
      ppF = node
      node = node.m_next
    edge = @m_contactList
    while edge
      c = edge.contact
      edge = edge.next
      fixtureA = c.GetFixtureA()
      fixtureB = c.GetFixtureB()
      @m_world.m_contactManager.Destroy c  if fixture is fixtureA or fixture is fixtureB
    if @m_flags & b2Body.e_activeFlag
      broadPhase = @m_world.m_contactManager.m_broadPhase
      fixture.DestroyProxy broadPhase
    else

    fixture.Destroy()
    fixture.m_body = null
    fixture.m_next = null
    --@m_fixtureCount
    @ResetMassData()
    return

  b2Body::SetPositionAndAngle = (position, angle) ->
    angle = 0  if angle is `undefined`
    f = undefined
    return  if @m_world.IsLocked() is true
    @m_xf.R.Set angle
    @m_xf.position.SetV position
    tMat = @m_xf.R
    tVec = @m_sweep.localCenter
    @m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y)
    @m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
    @m_sweep.c.x += @m_xf.position.x
    @m_sweep.c.y += @m_xf.position.y
    @m_sweep.c0.SetV @m_sweep.c
    @m_sweep.a0 = @m_sweep.a = angle
    broadPhase = @m_world.m_contactManager.m_broadPhase
    f = @m_fixtureList
    while f
      f.Synchronize broadPhase, @m_xf, @m_xf
      f = f.m_next
    @m_world.m_contactManager.FindNewContacts()
    return

  b2Body::SetTransform = (xf) ->
    @SetPositionAndAngle xf.position, xf.GetAngle()
    return

  b2Body::GetTransform = ->
    @m_xf

  b2Body::GetPosition = ->
    @m_xf.position

  b2Body::SetPosition = (position) ->
    @SetPositionAndAngle position, @GetAngle()
    return

  b2Body::GetAngle = ->
    @m_sweep.a

  b2Body::SetAngle = (angle) ->
    angle = 0  if angle is `undefined`
    @SetPositionAndAngle @GetPosition(), angle
    return

  b2Body::GetWorldCenter = ->
    @m_sweep.c

  b2Body::GetLocalCenter = ->
    @m_sweep.localCenter

  b2Body::SetLinearVelocity = (v) ->
    return  if @m_type is b2Body.b2_staticBody
    @m_linearVelocity.SetV v
    return

  b2Body::GetLinearVelocity = ->
    @m_linearVelocity

  b2Body::SetAngularVelocity = (omega) ->
    omega = 0  if omega is `undefined`
    return  if @m_type is b2Body.b2_staticBody
    @m_angularVelocity = omega
    return

  b2Body::GetAngularVelocity = ->
    @m_angularVelocity

  b2Body::GetDefinition = ->
    bd = new b2BodyDef()
    bd.type = @GetType()
    bd.allowSleep = (@m_flags & b2Body.e_allowSleepFlag) is b2Body.e_allowSleepFlag
    bd.angle = @GetAngle()
    bd.angularDamping = @m_angularDamping
    bd.angularVelocity = @m_angularVelocity
    bd.fixedRotation = (@m_flags & b2Body.e_fixedRotationFlag) is b2Body.e_fixedRotationFlag
    bd.bullet = (@m_flags & b2Body.e_bulletFlag) is b2Body.e_bulletFlag
    bd.awake = (@m_flags & b2Body.e_awakeFlag) is b2Body.e_awakeFlag
    bd.linearDamping = @m_linearDamping
    bd.linearVelocity.SetV @GetLinearVelocity()
    bd.position = @GetPosition()
    bd.userData = @GetUserData()
    bd

  b2Body::ApplyForce = (force, point) ->
    return  unless @m_type is b2Body.b2_dynamicBody
    @SetAwake true  if @IsAwake() is false
    @m_force.x += force.x
    @m_force.y += force.y
    @m_torque += ((point.x - @m_sweep.c.x) * force.y - (point.y - @m_sweep.c.y) * force.x)
    return

  b2Body::ApplyTorque = (torque) ->
    torque = 0  if torque is `undefined`
    return  unless @m_type is b2Body.b2_dynamicBody
    @SetAwake true  if @IsAwake() is false
    @m_torque += torque
    return

  b2Body::ApplyImpulse = (impulse, point) ->
    return  unless @m_type is b2Body.b2_dynamicBody
    @SetAwake true  if @IsAwake() is false
    @m_linearVelocity.x += @m_invMass * impulse.x
    @m_linearVelocity.y += @m_invMass * impulse.y
    @m_angularVelocity += @m_invI * ((point.x - @m_sweep.c.x) * impulse.y - (point.y - @m_sweep.c.y) * impulse.x)
    return

  b2Body::Split = (callback) ->
    linearVelocity = @GetLinearVelocity().Copy()
    angularVelocity = @GetAngularVelocity()
    center = @GetWorldCenter()
    body1 = this
    body2 = @m_world.CreateBody(@GetDefinition())
    prev = undefined
    f = body1.m_fixtureList

    while f
      if callback(f)
        next = f.m_next
        if prev
          prev.m_next = next
        else
          body1.m_fixtureList = next
        body1.m_fixtureCount--
        f.m_next = body2.m_fixtureList
        body2.m_fixtureList = f
        body2.m_fixtureCount++
        f.m_body = body2
        f = next
      else
        prev = f
        f = f.m_next
    body1.ResetMassData()
    body2.ResetMassData()
    center1 = body1.GetWorldCenter()
    center2 = body2.GetWorldCenter()
    velocity1 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center1, center)))
    velocity2 = b2Math.AddVV(linearVelocity, b2Math.CrossFV(angularVelocity, b2Math.SubtractVV(center2, center)))
    body1.SetLinearVelocity velocity1
    body2.SetLinearVelocity velocity2
    body1.SetAngularVelocity angularVelocity
    body2.SetAngularVelocity angularVelocity
    body1.SynchronizeFixtures()
    body2.SynchronizeFixtures()
    body2

  b2Body::Merge = (other) ->
    f = undefined
    f = other.m_fixtureList
    while f
      next = f.m_next
      other.m_fixtureCount--
      f.m_next = @m_fixtureList
      @m_fixtureList = f
      @m_fixtureCount++
      f.m_body = body2
      f = next
    body1.m_fixtureCount = 0
    body1 = this
    body2 = other
    center1 = body1.GetWorldCenter()
    center2 = body2.GetWorldCenter()
    velocity1 = body1.GetLinearVelocity().Copy()
    velocity2 = body2.GetLinearVelocity().Copy()
    angular1 = body1.GetAngularVelocity()
    angular = body2.GetAngularVelocity()
    body1.ResetMassData()
    @SynchronizeFixtures()
    return

  b2Body::GetMass = ->
    @m_mass

  b2Body::GetInertia = ->
    @m_I

  b2Body::GetMassData = (data) ->
    data.mass = @m_mass
    data.I = @m_I
    data.center.SetV @m_sweep.localCenter
    return

  b2Body::SetMassData = (massData) ->
    b2Settings.b2Assert @m_world.IsLocked() is false
    return  if @m_world.IsLocked() is true
    return  unless @m_type is b2Body.b2_dynamicBody
    @m_invMass = 0.0
    @m_I = 0.0
    @m_invI = 0.0
    @m_mass = massData.mass
    @m_mass = 1.0  if @m_mass <= 0.0
    @m_invMass = 1.0 / @m_mass
    if massData.I > 0.0 and (@m_flags & b2Body.e_fixedRotationFlag) is 0
      @m_I = massData.I - @m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y)
      @m_invI = 1.0 / @m_I
    oldCenter = @m_sweep.c.Copy()
    @m_sweep.localCenter.SetV massData.center
    @m_sweep.c0.SetV b2Math.MulX(@m_xf, @m_sweep.localCenter)
    @m_sweep.c.SetV @m_sweep.c0
    @m_linearVelocity.x += @m_angularVelocity * (-(@m_sweep.c.y - oldCenter.y))
    @m_linearVelocity.y += @m_angularVelocity * (+(@m_sweep.c.x - oldCenter.x))
    return

  b2Body::ResetMassData = ->
    @m_mass = 0.0
    @m_invMass = 0.0
    @m_I = 0.0
    @m_invI = 0.0
    @m_sweep.localCenter.SetZero()
    return  if @m_type is b2Body.b2_staticBody or @m_type is b2Body.b2_kinematicBody
    center = b2Vec2.Make(0, 0)
    f = @m_fixtureList

    while f
      continue  if f.m_density is 0.0
      massData = f.GetMassData()
      @m_mass += massData.mass
      center.x += massData.center.x * massData.mass
      center.y += massData.center.y * massData.mass
      @m_I += massData.I
      f = f.m_next
    if @m_mass > 0.0
      @m_invMass = 1.0 / @m_mass
      center.x *= @m_invMass
      center.y *= @m_invMass
    else
      @m_mass = 1.0
      @m_invMass = 1.0
    if @m_I > 0.0 and (@m_flags & b2Body.e_fixedRotationFlag) is 0
      @m_I -= @m_mass * (center.x * center.x + center.y * center.y)
      @m_I *= @m_inertiaScale
      b2Settings.b2Assert @m_I > 0
      @m_invI = 1.0 / @m_I
    else
      @m_I = 0.0
      @m_invI = 0.0
    oldCenter = @m_sweep.c.Copy()
    @m_sweep.localCenter.SetV center
    @m_sweep.c0.SetV b2Math.MulX(@m_xf, @m_sweep.localCenter)
    @m_sweep.c.SetV @m_sweep.c0
    @m_linearVelocity.x += @m_angularVelocity * (-(@m_sweep.c.y - oldCenter.y))
    @m_linearVelocity.y += @m_angularVelocity * (+(@m_sweep.c.x - oldCenter.x))
    return

  b2Body::GetWorldPoint = (localPoint) ->
    A = @m_xf.R
    u = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y)
    u.x += @m_xf.position.x
    u.y += @m_xf.position.y
    u

  b2Body::GetWorldVector = (localVector) ->
    b2Math.MulMV @m_xf.R, localVector

  b2Body::GetLocalPoint = (worldPoint) ->
    b2Math.MulXT @m_xf, worldPoint

  b2Body::GetLocalVector = (worldVector) ->
    b2Math.MulTMV @m_xf.R, worldVector

  b2Body::GetLinearVelocityFromWorldPoint = (worldPoint) ->
    new b2Vec2(@m_linearVelocity.x - @m_angularVelocity * (worldPoint.y - @m_sweep.c.y), @m_linearVelocity.y + @m_angularVelocity * (worldPoint.x - @m_sweep.c.x))

  b2Body::GetLinearVelocityFromLocalPoint = (localPoint) ->
    A = @m_xf.R
    worldPoint = new b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y)
    worldPoint.x += @m_xf.position.x
    worldPoint.y += @m_xf.position.y
    new b2Vec2(@m_linearVelocity.x - @m_angularVelocity * (worldPoint.y - @m_sweep.c.y), @m_linearVelocity.y + @m_angularVelocity * (worldPoint.x - @m_sweep.c.x))

  b2Body::GetLinearDamping = ->
    @m_linearDamping

  b2Body::SetLinearDamping = (linearDamping) ->
    linearDamping = 0  if linearDamping is `undefined`
    @m_linearDamping = linearDamping
    return

  b2Body::GetAngularDamping = ->
    @m_angularDamping

  b2Body::SetAngularDamping = (angularDamping) ->
    angularDamping = 0  if angularDamping is `undefined`
    @m_angularDamping = angularDamping
    return

  b2Body::SetType = (type) ->
    type = 0  if type is `undefined`
    return  if @m_type is type
    @m_type = type
    @ResetMassData()
    if @m_type is b2Body.b2_staticBody
      @m_linearVelocity.SetZero()
      @m_angularVelocity = 0.0
    @SetAwake true
    @m_force.SetZero()
    @m_torque = 0.0
    ce = @m_contactList

    while ce
      ce.contact.FlagForFiltering()
      ce = ce.next
    return

  b2Body::GetType = ->
    @m_type

  b2Body::SetBullet = (flag) ->
    if flag
      @m_flags |= b2Body.e_bulletFlag
    else
      @m_flags &= ~b2Body.e_bulletFlag
    return

  b2Body::IsBullet = ->
    (@m_flags & b2Body.e_bulletFlag) is b2Body.e_bulletFlag

  b2Body::SetSleepingAllowed = (flag) ->
    if flag
      @m_flags |= b2Body.e_allowSleepFlag
    else
      @m_flags &= ~b2Body.e_allowSleepFlag
      @SetAwake true
    return

  b2Body::SetAwake = (flag) ->
    if flag
      @m_flags |= b2Body.e_awakeFlag
      @m_sleepTime = 0.0
    else
      @m_flags &= ~b2Body.e_awakeFlag
      @m_sleepTime = 0.0
      @m_linearVelocity.SetZero()
      @m_angularVelocity = 0.0
      @m_force.SetZero()
      @m_torque = 0.0
    return

  b2Body::IsAwake = ->
    (@m_flags & b2Body.e_awakeFlag) is b2Body.e_awakeFlag

  b2Body::SetFixedRotation = (fixed) ->
    if fixed
      @m_flags |= b2Body.e_fixedRotationFlag
    else
      @m_flags &= ~b2Body.e_fixedRotationFlag
    @ResetMassData()
    return

  b2Body::IsFixedRotation = ->
    (@m_flags & b2Body.e_fixedRotationFlag) is b2Body.e_fixedRotationFlag

  b2Body::SetActive = (flag) ->
    return  if flag is @IsActive()
    broadPhase = undefined
    f = undefined
    if flag
      @m_flags |= b2Body.e_activeFlag
      broadPhase = @m_world.m_contactManager.m_broadPhase
      f = @m_fixtureList
      while f
        f.CreateProxy broadPhase, @m_xf
        f = f.m_next
    else
      @m_flags &= ~b2Body.e_activeFlag
      broadPhase = @m_world.m_contactManager.m_broadPhase
      f = @m_fixtureList
      while f
        f.DestroyProxy broadPhase
        f = f.m_next
      ce = @m_contactList
      while ce
        ce0 = ce
        ce = ce.next
        @m_world.m_contactManager.Destroy ce0.contact
      @m_contactList = null
    return

  b2Body::IsActive = ->
    (@m_flags & b2Body.e_activeFlag) is b2Body.e_activeFlag

  b2Body::IsSleepingAllowed = ->
    (@m_flags & b2Body.e_allowSleepFlag) is b2Body.e_allowSleepFlag

  b2Body::GetFixtureList = ->
    @m_fixtureList

  b2Body::GetJointList = ->
    @m_jointList

  b2Body::GetControllerList = ->
    @m_controllerList

  b2Body::GetContactList = ->
    @m_contactList

  b2Body::GetNext = ->
    @m_next

  b2Body::GetUserData = ->
    @m_userData

  b2Body::SetUserData = (data) ->
    @m_userData = data
    return

  b2Body::GetWorld = ->
    @m_world

  b2Body::b2Body = (bd, world) ->
    @m_flags = 0
    @m_flags |= b2Body.e_bulletFlag  if bd.bullet
    @m_flags |= b2Body.e_fixedRotationFlag  if bd.fixedRotation
    @m_flags |= b2Body.e_allowSleepFlag  if bd.allowSleep
    @m_flags |= b2Body.e_awakeFlag  if bd.awake
    @m_flags |= b2Body.e_activeFlag  if bd.active
    @m_world = world
    @m_xf.position.SetV bd.position
    @m_xf.R.Set bd.angle
    @m_sweep.localCenter.SetZero()
    @m_sweep.t0 = 1.0
    @m_sweep.a0 = @m_sweep.a = bd.angle
    tMat = @m_xf.R
    tVec = @m_sweep.localCenter
    @m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y)
    @m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
    @m_sweep.c.x += @m_xf.position.x
    @m_sweep.c.y += @m_xf.position.y
    @m_sweep.c0.SetV @m_sweep.c
    @m_jointList = null
    @m_controllerList = null
    @m_contactList = null
    @m_controllerCount = 0
    @m_prev = null
    @m_next = null
    @m_linearVelocity.SetV bd.linearVelocity
    @m_angularVelocity = bd.angularVelocity
    @m_linearDamping = bd.linearDamping
    @m_angularDamping = bd.angularDamping
    @m_force.Set 0.0, 0.0
    @m_torque = 0.0
    @m_sleepTime = 0.0
    @m_type = bd.type
    if @m_type is b2Body.b2_dynamicBody
      @m_mass = 1.0
      @m_invMass = 1.0
    else
      @m_mass = 0.0
      @m_invMass = 0.0
    @m_I = 0.0
    @m_invI = 0.0
    @m_inertiaScale = bd.inertiaScale
    @m_userData = bd.userData
    @m_fixtureList = null
    @m_fixtureCount = 0
    return

  b2Body::SynchronizeFixtures = ->
    xf1 = b2Body.s_xf1
    xf1.R.Set @m_sweep.a0
    tMat = xf1.R
    tVec = @m_sweep.localCenter
    xf1.position.x = @m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y)
    xf1.position.y = @m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
    f = undefined
    broadPhase = @m_world.m_contactManager.m_broadPhase
    f = @m_fixtureList
    while f
      f.Synchronize broadPhase, xf1, @m_xf
      f = f.m_next
    return

  b2Body::SynchronizeTransform = ->
    @m_xf.R.Set @m_sweep.a
    tMat = @m_xf.R
    tVec = @m_sweep.localCenter
    @m_xf.position.x = @m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y)
    @m_xf.position.y = @m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y)
    return

  b2Body::ShouldCollide = (other) ->
    return false  if @m_type isnt b2Body.b2_dynamicBody and other.m_type isnt b2Body.b2_dynamicBody
    jn = @m_jointList

    while jn
      return false  if jn.joint.m_collideConnected is false  if jn.other is other
      jn = jn.next
    true

  b2Body::Advance = (t) ->
    t = 0  if t is `undefined`
    @m_sweep.Advance t
    @m_sweep.c.SetV @m_sweep.c0
    @m_sweep.a = @m_sweep.a0
    @SynchronizeTransform()
    return

  Box2D.postDefs.push ->
    Box2D.Dynamics.b2Body.s_xf1 = new b2Transform()
    Box2D.Dynamics.b2Body.e_islandFlag = 0x0001
    Box2D.Dynamics.b2Body.e_awakeFlag = 0x0002
    Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x0004
    Box2D.Dynamics.b2Body.e_bulletFlag = 0x0008
    Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x0010
    Box2D.Dynamics.b2Body.e_activeFlag = 0x0020
    Box2D.Dynamics.b2Body.b2_staticBody = 0
    Box2D.Dynamics.b2Body.b2_kinematicBody = 1
    Box2D.Dynamics.b2Body.b2_dynamicBody = 2
    return

  b2BodyDef.b2BodyDef = ->
    @position = new b2Vec2()
    @linearVelocity = new b2Vec2()
    return

  b2BodyDef::b2BodyDef = ->
    @userData = null
    @position.Set 0.0, 0.0
    @angle = 0.0
    @linearVelocity.Set 0, 0
    @angularVelocity = 0.0
    @linearDamping = 0.0
    @angularDamping = 0.0
    @allowSleep = true
    @awake = true
    @fixedRotation = false
    @bullet = false
    @type = b2Body.b2_staticBody
    @active = true
    @inertiaScale = 1.0
    return

  b2ContactFilter.b2ContactFilter = ->

  b2ContactFilter::ShouldCollide = (fixtureA, fixtureB) ->
    filter1 = fixtureA.GetFilterData()
    filter2 = fixtureB.GetFilterData()
    return filter1.groupIndex > 0  if filter1.groupIndex is filter2.groupIndex and filter1.groupIndex isnt 0
    collide = (filter1.maskBits & filter2.categoryBits) isnt 0 and (filter1.categoryBits & filter2.maskBits) isnt 0
    collide

  b2ContactFilter::RayCollide = (userData, fixture) ->
    return true  unless userData
    @ShouldCollide ((if userData instanceof b2Fixture then userData else null)), fixture

  Box2D.postDefs.push ->
    Box2D.Dynamics.b2ContactFilter.b2_defaultFilter = new b2ContactFilter()
    return

  b2ContactImpulse.b2ContactImpulse = ->
    @normalImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints)
    @tangentImpulses = new Vector_a2j_Number(b2Settings.b2_maxManifoldPoints)
    return

  b2ContactListener.b2ContactListener = ->

  b2ContactListener::BeginContact = (contact) ->

  b2ContactListener::EndContact = (contact) ->

  b2ContactListener::PreSolve = (contact, oldManifold) ->

  b2ContactListener::PostSolve = (contact, impulse) ->

  Box2D.postDefs.push ->
    Box2D.Dynamics.b2ContactListener.b2_defaultListener = new b2ContactListener()
    return

  b2ContactManager.b2ContactManager = ->

  b2ContactManager::b2ContactManager = ->
    @m_world = null
    @m_contactCount = 0
    @m_contactFilter = b2ContactFilter.b2_defaultFilter
    @m_contactListener = b2ContactListener.b2_defaultListener
    @m_contactFactory = new b2ContactFactory(@m_allocator)
    @m_broadPhase = new b2DynamicTreeBroadPhase()
    return

  b2ContactManager::AddPair = (proxyUserDataA, proxyUserDataB) ->
    fixtureA = ((if proxyUserDataA instanceof b2Fixture then proxyUserDataA else null))
    fixtureB = ((if proxyUserDataB instanceof b2Fixture then proxyUserDataB else null))
    bodyA = fixtureA.GetBody()
    bodyB = fixtureB.GetBody()
    return  if bodyA is bodyB
    edge = bodyB.GetContactList()
    while edge
      if edge.other is bodyA
        fA = edge.contact.GetFixtureA()
        fB = edge.contact.GetFixtureB()
        return  if fA is fixtureA and fB is fixtureB
        return  if fA is fixtureB and fB is fixtureA
      edge = edge.next
    return  if bodyB.ShouldCollide(bodyA) is false
    return  if @m_contactFilter.ShouldCollide(fixtureA, fixtureB) is false
    c = @m_contactFactory.Create(fixtureA, fixtureB)
    fixtureA = c.GetFixtureA()
    fixtureB = c.GetFixtureB()
    bodyA = fixtureA.m_body
    bodyB = fixtureB.m_body
    c.m_prev = null
    c.m_next = @m_world.m_contactList
    @m_world.m_contactList.m_prev = c  if @m_world.m_contactList?
    @m_world.m_contactList = c
    c.m_nodeA.contact = c
    c.m_nodeA.other = bodyB
    c.m_nodeA.prev = null
    c.m_nodeA.next = bodyA.m_contactList
    bodyA.m_contactList.prev = c.m_nodeA  if bodyA.m_contactList?
    bodyA.m_contactList = c.m_nodeA
    c.m_nodeB.contact = c
    c.m_nodeB.other = bodyA
    c.m_nodeB.prev = null
    c.m_nodeB.next = bodyB.m_contactList
    bodyB.m_contactList.prev = c.m_nodeB  if bodyB.m_contactList?
    bodyB.m_contactList = c.m_nodeB
    ++@m_world.m_contactCount
    return

  b2ContactManager::FindNewContacts = ->
    @m_broadPhase.UpdatePairs Box2D.generateCallback(this, @AddPair)
    return

  b2ContactManager::Destroy = (c) ->
    fixtureA = c.GetFixtureA()
    fixtureB = c.GetFixtureB()
    bodyA = fixtureA.GetBody()
    bodyB = fixtureB.GetBody()
    @m_contactListener.EndContact c  if c.IsTouching()
    c.m_prev.m_next = c.m_next  if c.m_prev
    c.m_next.m_prev = c.m_prev  if c.m_next
    @m_world.m_contactList = c.m_next  if c is @m_world.m_contactList
    c.m_nodeA.prev.next = c.m_nodeA.next  if c.m_nodeA.prev
    c.m_nodeA.next.prev = c.m_nodeA.prev  if c.m_nodeA.next
    bodyA.m_contactList = c.m_nodeA.next  if c.m_nodeA is bodyA.m_contactList
    c.m_nodeB.prev.next = c.m_nodeB.next  if c.m_nodeB.prev
    c.m_nodeB.next.prev = c.m_nodeB.prev  if c.m_nodeB.next
    bodyB.m_contactList = c.m_nodeB.next  if c.m_nodeB is bodyB.m_contactList
    @m_contactFactory.Destroy c
    --@m_contactCount
    return

  b2ContactManager::Collide = ->
    c = @m_world.m_contactList
    while c
      fixtureA = c.GetFixtureA()
      fixtureB = c.GetFixtureB()
      bodyA = fixtureA.GetBody()
      bodyB = fixtureB.GetBody()
      if bodyA.IsAwake() is false and bodyB.IsAwake() is false
        c = c.GetNext()
        continue
      if c.m_flags & b2Contact.e_filterFlag
        if bodyB.ShouldCollide(bodyA) is false
          cNuke = c
          c = cNuke.GetNext()
          @Destroy cNuke
          continue
        if @m_contactFilter.ShouldCollide(fixtureA, fixtureB) is false
          cNuke = c
          c = cNuke.GetNext()
          @Destroy cNuke
          continue
        c.m_flags &= ~b2Contact.e_filterFlag
      proxyA = fixtureA.m_proxy
      proxyB = fixtureB.m_proxy
      overlap = @m_broadPhase.TestOverlap(proxyA, proxyB)
      if overlap is false
        cNuke = c
        c = cNuke.GetNext()
        @Destroy cNuke
        continue
      c.Update @m_contactListener
      c = c.GetNext()
    return

  Box2D.postDefs.push ->
    Box2D.Dynamics.b2ContactManager.s_evalCP = new b2ContactPoint()
    return

  b2DebugDraw.b2DebugDraw = ->

  b2DebugDraw::b2DebugDraw = ->

  b2DebugDraw::SetFlags = (flags) ->
    flags = 0  if flags is `undefined`
    return

  b2DebugDraw::GetFlags = ->

  b2DebugDraw::AppendFlags = (flags) ->
    flags = 0  if flags is `undefined`
    return

  b2DebugDraw::ClearFlags = (flags) ->
    flags = 0  if flags is `undefined`
    return

  b2DebugDraw::SetSprite = (sprite) ->

  b2DebugDraw::GetSprite = ->

  b2DebugDraw::SetDrawScale = (drawScale) ->
    drawScale = 0  if drawScale is `undefined`
    return

  b2DebugDraw::GetDrawScale = ->

  b2DebugDraw::SetLineThickness = (lineThickness) ->
    lineThickness = 0  if lineThickness is `undefined`
    return

  b2DebugDraw::GetLineThickness = ->

  b2DebugDraw::SetAlpha = (alpha) ->
    alpha = 0  if alpha is `undefined`
    return

  b2DebugDraw::GetAlpha = ->

  b2DebugDraw::SetFillAlpha = (alpha) ->
    alpha = 0  if alpha is `undefined`
    return

  b2DebugDraw::GetFillAlpha = ->

  b2DebugDraw::SetXFormScale = (xformScale) ->
    xformScale = 0  if xformScale is `undefined`
    return

  b2DebugDraw::GetXFormScale = ->

  b2DebugDraw::DrawPolygon = (vertices, vertexCount, color) ->
    vertexCount = 0  if vertexCount is `undefined`
    return

  b2DebugDraw::DrawSolidPolygon = (vertices, vertexCount, color) ->
    vertexCount = 0  if vertexCount is `undefined`
    return

  b2DebugDraw::DrawCircle = (center, radius, color) ->
    radius = 0  if radius is `undefined`
    return

  b2DebugDraw::DrawSolidCircle = (center, radius, axis, color) ->
    radius = 0  if radius is `undefined`
    return

  b2DebugDraw::DrawSegment = (p1, p2, color) ->

  b2DebugDraw::DrawTransform = (xf) ->

  Box2D.postDefs.push ->
    Box2D.Dynamics.b2DebugDraw.e_shapeBit = 0x0001
    Box2D.Dynamics.b2DebugDraw.e_jointBit = 0x0002
    Box2D.Dynamics.b2DebugDraw.e_aabbBit = 0x0004
    Box2D.Dynamics.b2DebugDraw.e_pairBit = 0x0008
    Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit = 0x0010
    Box2D.Dynamics.b2DebugDraw.e_controllerBit = 0x0020
    return

  b2DestructionListener.b2DestructionListener = ->

  b2DestructionListener::SayGoodbyeJoint = (joint) ->

  b2DestructionListener::SayGoodbyeFixture = (fixture) ->

  b2FilterData.b2FilterData = ->
    @categoryBits = 0x0001
    @maskBits = 0xFFFF
    @groupIndex = 0
    return

  b2FilterData::Copy = ->
    copy = new b2FilterData()
    copy.categoryBits = @categoryBits
    copy.maskBits = @maskBits
    copy.groupIndex = @groupIndex
    copy

  b2Fixture.b2Fixture = ->
    @m_filter = new b2FilterData()
    return

  b2Fixture::GetType = ->
    @m_shape.GetType()

  b2Fixture::GetShape = ->
    @m_shape

  b2Fixture::SetSensor = (sensor) ->
    return  if @m_isSensor is sensor
    @m_isSensor = sensor
    return  unless @m_body?
    edge = @m_body.GetContactList()
    while edge
      contact = edge.contact
      fixtureA = contact.GetFixtureA()
      fixtureB = contact.GetFixtureB()
      contact.SetSensor fixtureA.IsSensor() or fixtureB.IsSensor()  if fixtureA is this or fixtureB is this
      edge = edge.next
    return

  b2Fixture::IsSensor = ->
    @m_isSensor

  b2Fixture::SetFilterData = (filter) ->
    @m_filter = filter.Copy()
    return  if @m_body
    edge = @m_body.GetContactList()
    while edge
      contact = edge.contact
      fixtureA = contact.GetFixtureA()
      fixtureB = contact.GetFixtureB()
      contact.FlagForFiltering()  if fixtureA is this or fixtureB is this
      edge = edge.next
    return

  b2Fixture::GetFilterData = ->
    @m_filter.Copy()

  b2Fixture::GetBody = ->
    @m_body

  b2Fixture::GetNext = ->
    @m_next

  b2Fixture::GetUserData = ->
    @m_userData

  b2Fixture::SetUserData = (data) ->
    @m_userData = data
    return

  b2Fixture::TestPoint = (p) ->
    @m_shape.TestPoint @m_body.GetTransform(), p

  b2Fixture::RayCast = (output, input) ->
    @m_shape.RayCast output, input, @m_body.GetTransform()

  b2Fixture::GetMassData = (massData) ->
    massData = null  if massData is `undefined`
    massData = new b2MassData()  unless massData?
    @m_shape.ComputeMass massData, @m_density
    massData

  b2Fixture::SetDensity = (density) ->
    density = 0  if density is `undefined`
    @m_density = density
    return

  b2Fixture::GetDensity = ->
    @m_density

  b2Fixture::GetFriction = ->
    @m_friction

  b2Fixture::SetFriction = (friction) ->
    friction = 0  if friction is `undefined`
    @m_friction = friction
    return

  b2Fixture::GetRestitution = ->
    @m_restitution

  b2Fixture::SetRestitution = (restitution) ->
    restitution = 0  if restitution is `undefined`
    @m_restitution = restitution
    return

  b2Fixture::GetAABB = ->
    @m_aabb

  b2Fixture::b2Fixture = ->
    @m_aabb = new b2AABB()
    @m_userData = null
    @m_body = null
    @m_next = null
    @m_shape = null
    @m_density = 0.0
    @m_friction = 0.0
    @m_restitution = 0.0
    return

  b2Fixture::Create = (body, xf, def) ->
    @m_userData = def.userData
    @m_friction = def.friction
    @m_restitution = def.restitution
    @m_body = body
    @m_next = null
    @m_filter = def.filter.Copy()
    @m_isSensor = def.isSensor
    @m_shape = def.shape.Copy()
    @m_density = def.density
    return

  b2Fixture::Destroy = ->
    @m_shape = null
    return

  b2Fixture::CreateProxy = (broadPhase, xf) ->
    @m_shape.ComputeAABB @m_aabb, xf
    @m_proxy = broadPhase.CreateProxy(@m_aabb, this)
    return

  b2Fixture::DestroyProxy = (broadPhase) ->
    return  unless @m_proxy?
    broadPhase.DestroyProxy @m_proxy
    @m_proxy = null
    return

  b2Fixture::Synchronize = (broadPhase, transform1, transform2) ->
    return  unless @m_proxy
    aabb1 = new b2AABB()
    aabb2 = new b2AABB()
    @m_shape.ComputeAABB aabb1, transform1
    @m_shape.ComputeAABB aabb2, transform2
    @m_aabb.Combine aabb1, aabb2
    displacement = b2Math.SubtractVV(transform2.position, transform1.position)
    broadPhase.MoveProxy @m_proxy, @m_aabb, displacement
    return

  b2FixtureDef.b2FixtureDef = ->
    @filter = new b2FilterData()
    return

  b2FixtureDef::b2FixtureDef = ->
    @shape = null
    @userData = null
    @friction = 0.2
    @restitution = 0.0
    @density = 0.0
    @filter.categoryBits = 0x0001
    @filter.maskBits = 0xFFFF
    @filter.groupIndex = 0
    @isSensor = false
    return

  b2Island.b2Island = ->

  b2Island::b2Island = ->
    @m_bodies = new Vector()
    @m_contacts = new Vector()
    @m_joints = new Vector()
    return

  b2Island::Initialize = (bodyCapacity, contactCapacity, jointCapacity, allocator, listener, contactSolver) ->
    bodyCapacity = 0  if bodyCapacity is `undefined`
    contactCapacity = 0  if contactCapacity is `undefined`
    jointCapacity = 0  if jointCapacity is `undefined`
    i = 0
    @m_bodyCapacity = bodyCapacity
    @m_contactCapacity = contactCapacity
    @m_jointCapacity = jointCapacity
    @m_bodyCount = 0
    @m_contactCount = 0
    @m_jointCount = 0
    @m_allocator = allocator
    @m_listener = listener
    @m_contactSolver = contactSolver
    i = @m_bodies.length
    while i < bodyCapacity
      @m_bodies[i] = null
      i++
    i = @m_contacts.length
    while i < contactCapacity
      @m_contacts[i] = null
      i++
    i = @m_joints.length
    while i < jointCapacity
      @m_joints[i] = null
      i++
    return

  b2Island::Clear = ->
    @m_bodyCount = 0
    @m_contactCount = 0
    @m_jointCount = 0
    return

  b2Island::Solve = (step, gravity, allowSleep) ->
    i = 0
    j = 0
    b = undefined
    joint = undefined
    i = 0
    while i < @m_bodyCount
      b = @m_bodies[i]
      continue  unless b.GetType() is b2Body.b2_dynamicBody
      b.m_linearVelocity.x += step.dt * (gravity.x + b.m_invMass * b.m_force.x)
      b.m_linearVelocity.y += step.dt * (gravity.y + b.m_invMass * b.m_force.y)
      b.m_angularVelocity += step.dt * b.m_invI * b.m_torque
      b.m_linearVelocity.Multiply b2Math.Clamp(1.0 - step.dt * b.m_linearDamping, 0.0, 1.0)
      b.m_angularVelocity *= b2Math.Clamp(1.0 - step.dt * b.m_angularDamping, 0.0, 1.0)
      ++i
    @m_contactSolver.Initialize step, @m_contacts, @m_contactCount, @m_allocator
    contactSolver = @m_contactSolver
    contactSolver.InitVelocityConstraints step
    i = 0
    while i < @m_jointCount
      joint = @m_joints[i]
      joint.InitVelocityConstraints step
      ++i
    i = 0
    while i < step.velocityIterations
      j = 0
      while j < @m_jointCount
        joint = @m_joints[j]
        joint.SolveVelocityConstraints step
        ++j
      contactSolver.SolveVelocityConstraints()
      ++i
    i = 0
    while i < @m_jointCount
      joint = @m_joints[i]
      joint.FinalizeVelocityConstraints()
      ++i
    contactSolver.FinalizeVelocityConstraints()
    i = 0
    while i < @m_bodyCount
      b = @m_bodies[i]
      continue  if b.GetType() is b2Body.b2_staticBody
      translationX = step.dt * b.m_linearVelocity.x
      translationY = step.dt * b.m_linearVelocity.y
      if (translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared
        b.m_linearVelocity.Normalize()
        b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * step.inv_dt
        b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * step.inv_dt
      rotation = step.dt * b.m_angularVelocity
      if rotation * rotation > b2Settings.b2_maxRotationSquared
        if b.m_angularVelocity < 0.0
          b.m_angularVelocity = (-b2Settings.b2_maxRotation * step.inv_dt)
        else
          b.m_angularVelocity = b2Settings.b2_maxRotation * step.inv_dt
      b.m_sweep.c0.SetV b.m_sweep.c
      b.m_sweep.a0 = b.m_sweep.a
      b.m_sweep.c.x += step.dt * b.m_linearVelocity.x
      b.m_sweep.c.y += step.dt * b.m_linearVelocity.y
      b.m_sweep.a += step.dt * b.m_angularVelocity
      b.SynchronizeTransform()
      ++i
    i = 0
    while i < step.positionIterations
      contactsOkay = contactSolver.SolvePositionConstraints(b2Settings.b2_contactBaumgarte)
      jointsOkay = true
      j = 0
      while j < @m_jointCount
        joint = @m_joints[j]
        jointOkay = joint.SolvePositionConstraints(b2Settings.b2_contactBaumgarte)
        jointsOkay = jointsOkay and jointOkay
        ++j
      break  if contactsOkay and jointsOkay
      ++i
    @Report contactSolver.m_constraints
    if allowSleep
      minSleepTime = Number.MAX_VALUE
      linTolSqr = b2Settings.b2_linearSleepTolerance * b2Settings.b2_linearSleepTolerance
      angTolSqr = b2Settings.b2_angularSleepTolerance * b2Settings.b2_angularSleepTolerance
      i = 0
      while i < @m_bodyCount
        b = @m_bodies[i]
        continue  if b.GetType() is b2Body.b2_staticBody
        if (b.m_flags & b2Body.e_allowSleepFlag) is 0
          b.m_sleepTime = 0.0
          minSleepTime = 0.0
        if (b.m_flags & b2Body.e_allowSleepFlag) is 0 or b.m_angularVelocity * b.m_angularVelocity > angTolSqr or b2Math.Dot(b.m_linearVelocity, b.m_linearVelocity) > linTolSqr
          b.m_sleepTime = 0.0
          minSleepTime = 0.0
        else
          b.m_sleepTime += step.dt
          minSleepTime = b2Math.Min(minSleepTime, b.m_sleepTime)
        ++i
      if minSleepTime >= b2Settings.b2_timeToSleep
        i = 0
        while i < @m_bodyCount
          b = @m_bodies[i]
          b.SetAwake false
          ++i
    return

  b2Island::SolveTOI = (subStep) ->
    i = 0
    j = 0
    @m_contactSolver.Initialize subStep, @m_contacts, @m_contactCount, @m_allocator
    contactSolver = @m_contactSolver
    i = 0
    while i < @m_jointCount
      @m_joints[i].InitVelocityConstraints subStep
      ++i
    i = 0
    while i < subStep.velocityIterations
      contactSolver.SolveVelocityConstraints()
      j = 0
      while j < @m_jointCount
        @m_joints[j].SolveVelocityConstraints subStep
        ++j
      ++i
    i = 0
    while i < @m_bodyCount
      b = @m_bodies[i]
      continue  if b.GetType() is b2Body.b2_staticBody
      translationX = subStep.dt * b.m_linearVelocity.x
      translationY = subStep.dt * b.m_linearVelocity.y
      if (translationX * translationX + translationY * translationY) > b2Settings.b2_maxTranslationSquared
        b.m_linearVelocity.Normalize()
        b.m_linearVelocity.x *= b2Settings.b2_maxTranslation * subStep.inv_dt
        b.m_linearVelocity.y *= b2Settings.b2_maxTranslation * subStep.inv_dt
      rotation = subStep.dt * b.m_angularVelocity
      if rotation * rotation > b2Settings.b2_maxRotationSquared
        if b.m_angularVelocity < 0.0
          b.m_angularVelocity = (-b2Settings.b2_maxRotation * subStep.inv_dt)
        else
          b.m_angularVelocity = b2Settings.b2_maxRotation * subStep.inv_dt
      b.m_sweep.c0.SetV b.m_sweep.c
      b.m_sweep.a0 = b.m_sweep.a
      b.m_sweep.c.x += subStep.dt * b.m_linearVelocity.x
      b.m_sweep.c.y += subStep.dt * b.m_linearVelocity.y
      b.m_sweep.a += subStep.dt * b.m_angularVelocity
      b.SynchronizeTransform()
      ++i
    k_toiBaumgarte = 0.75
    i = 0
    while i < subStep.positionIterations
      contactsOkay = contactSolver.SolvePositionConstraints(k_toiBaumgarte)
      jointsOkay = true
      j = 0
      while j < @m_jointCount
        jointOkay = @m_joints[j].SolvePositionConstraints(b2Settings.b2_contactBaumgarte)
        jointsOkay = jointsOkay and jointOkay
        ++j
      break  if contactsOkay and jointsOkay
      ++i
    @Report contactSolver.m_constraints
    return

  b2Island::Report = (constraints) ->
    return  unless @m_listener?
    i = 0

    while i < @m_contactCount
      c = @m_contacts[i]
      cc = constraints[i]
      j = 0

      while j < cc.pointCount
        b2Island.s_impulse.normalImpulses[j] = cc.points[j].normalImpulse
        b2Island.s_impulse.tangentImpulses[j] = cc.points[j].tangentImpulse
        ++j
      @m_listener.PostSolve c, b2Island.s_impulse
      ++i
    return

  b2Island::AddBody = (body) ->
    body.m_islandIndex = @m_bodyCount
    @m_bodies[@m_bodyCount++] = body
    return

  b2Island::AddContact = (contact) ->
    @m_contacts[@m_contactCount++] = contact
    return

  b2Island::AddJoint = (joint) ->
    @m_joints[@m_jointCount++] = joint
    return

  Box2D.postDefs.push ->
    Box2D.Dynamics.b2Island.s_impulse = new b2ContactImpulse()
    return

  b2TimeStep.b2TimeStep = ->

  b2TimeStep::Set = (step) ->
    @dt = step.dt
    @inv_dt = step.inv_dt
    @positionIterations = step.positionIterations
    @velocityIterations = step.velocityIterations
    @warmStarting = step.warmStarting
    return

  b2World.b2World = ->
    @s_stack = new Vector()
    @m_contactManager = new b2ContactManager()
    @m_contactSolver = new b2ContactSolver()
    @m_island = new b2Island()
    return

  b2World::b2World = (gravity, doSleep) ->
    @m_destructionListener = null
    @m_debugDraw = null
    @m_bodyList = null
    @m_contactList = null
    @m_jointList = null
    @m_controllerList = null
    @m_bodyCount = 0
    @m_contactCount = 0
    @m_jointCount = 0
    @m_controllerCount = 0
    b2World.m_warmStarting = true
    b2World.m_continuousPhysics = true
    @m_allowSleep = doSleep
    @m_gravity = gravity
    @m_inv_dt0 = 0.0
    @m_contactManager.m_world = this
    bd = new b2BodyDef()
    @m_groundBody = @CreateBody(bd)
    return

  b2World::SetDestructionListener = (listener) ->
    @m_destructionListener = listener
    return

  b2World::SetContactFilter = (filter) ->
    @m_contactManager.m_contactFilter = filter
    return

  b2World::SetContactListener = (listener) ->
    @m_contactManager.m_contactListener = listener
    return

  b2World::SetDebugDraw = (debugDraw) ->
    @m_debugDraw = debugDraw
    return

  b2World::SetBroadPhase = (broadPhase) ->
    oldBroadPhase = @m_contactManager.m_broadPhase
    @m_contactManager.m_broadPhase = broadPhase
    b = @m_bodyList

    while b
      f = b.m_fixtureList

      while f
        f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f)
        f = f.m_next
      b = b.m_next
    return

  b2World::Validate = ->
    @m_contactManager.m_broadPhase.Validate()
    return

  b2World::GetProxyCount = ->
    @m_contactManager.m_broadPhase.GetProxyCount()

  b2World::CreateBody = (def) ->
    return null  if @IsLocked() is true
    b = new b2Body(def, this)
    b.m_prev = null
    b.m_next = @m_bodyList
    @m_bodyList.m_prev = b  if @m_bodyList
    @m_bodyList = b
    ++@m_bodyCount
    b

  b2World::DestroyBody = (b) ->
    return  if @IsLocked() is true
    jn = b.m_jointList
    while jn
      jn0 = jn
      jn = jn.next
      @m_destructionListener.SayGoodbyeJoint jn0.joint  if @m_destructionListener
      @DestroyJoint jn0.joint
    coe = b.m_controllerList
    while coe
      coe0 = coe
      coe = coe.nextController
      coe0.controller.RemoveBody b
    ce = b.m_contactList
    while ce
      ce0 = ce
      ce = ce.next
      @m_contactManager.Destroy ce0.contact
    b.m_contactList = null
    f = b.m_fixtureList
    while f
      f0 = f
      f = f.m_next
      @m_destructionListener.SayGoodbyeFixture f0  if @m_destructionListener
      f0.DestroyProxy @m_contactManager.m_broadPhase
      f0.Destroy()
    b.m_fixtureList = null
    b.m_fixtureCount = 0
    b.m_prev.m_next = b.m_next  if b.m_prev
    b.m_next.m_prev = b.m_prev  if b.m_next
    @m_bodyList = b.m_next  if b is @m_bodyList
    --@m_bodyCount
    return

  b2World::CreateJoint = (def) ->
    j = b2Joint.Create(def, null)
    j.m_prev = null
    j.m_next = @m_jointList
    @m_jointList.m_prev = j  if @m_jointList
    @m_jointList = j
    ++@m_jointCount
    j.m_edgeA.joint = j
    j.m_edgeA.other = j.m_bodyB
    j.m_edgeA.prev = null
    j.m_edgeA.next = j.m_bodyA.m_jointList
    j.m_bodyA.m_jointList.prev = j.m_edgeA  if j.m_bodyA.m_jointList
    j.m_bodyA.m_jointList = j.m_edgeA
    j.m_edgeB.joint = j
    j.m_edgeB.other = j.m_bodyA
    j.m_edgeB.prev = null
    j.m_edgeB.next = j.m_bodyB.m_jointList
    j.m_bodyB.m_jointList.prev = j.m_edgeB  if j.m_bodyB.m_jointList
    j.m_bodyB.m_jointList = j.m_edgeB
    bodyA = def.bodyA
    bodyB = def.bodyB
    if def.collideConnected is false
      edge = bodyB.GetContactList()
      while edge
        edge.contact.FlagForFiltering()  if edge.other is bodyA
        edge = edge.next
    j

  b2World::DestroyJoint = (j) ->
    collideConnected = j.m_collideConnected
    j.m_prev.m_next = j.m_next  if j.m_prev
    j.m_next.m_prev = j.m_prev  if j.m_next
    @m_jointList = j.m_next  if j is @m_jointList
    bodyA = j.m_bodyA
    bodyB = j.m_bodyB
    bodyA.SetAwake true
    bodyB.SetAwake true
    j.m_edgeA.prev.next = j.m_edgeA.next  if j.m_edgeA.prev
    j.m_edgeA.next.prev = j.m_edgeA.prev  if j.m_edgeA.next
    bodyA.m_jointList = j.m_edgeA.next  if j.m_edgeA is bodyA.m_jointList
    j.m_edgeA.prev = null
    j.m_edgeA.next = null
    j.m_edgeB.prev.next = j.m_edgeB.next  if j.m_edgeB.prev
    j.m_edgeB.next.prev = j.m_edgeB.prev  if j.m_edgeB.next
    bodyB.m_jointList = j.m_edgeB.next  if j.m_edgeB is bodyB.m_jointList
    j.m_edgeB.prev = null
    j.m_edgeB.next = null
    b2Joint.Destroy j, null
    --@m_jointCount
    if collideConnected is false
      edge = bodyB.GetContactList()
      while edge
        edge.contact.FlagForFiltering()  if edge.other is bodyA
        edge = edge.next
    return

  b2World::AddController = (c) ->
    c.m_next = @m_controllerList
    c.m_prev = null
    @m_controllerList = c
    c.m_world = this
    @m_controllerCount++
    c

  b2World::RemoveController = (c) ->
    c.m_prev.m_next = c.m_next  if c.m_prev
    c.m_next.m_prev = c.m_prev  if c.m_next
    @m_controllerList = c.m_next  if @m_controllerList is c
    @m_controllerCount--
    return

  b2World::CreateController = (controller) ->
    throw new Error("Controller can only be a member of one world")  unless controller.m_world is this
    controller.m_next = @m_controllerList
    controller.m_prev = null
    @m_controllerList.m_prev = controller  if @m_controllerList
    @m_controllerList = controller
    ++@m_controllerCount
    controller.m_world = this
    controller

  b2World::DestroyController = (controller) ->
    controller.Clear()
    controller.m_next.m_prev = controller.m_prev  if controller.m_next
    controller.m_prev.m_next = controller.m_next  if controller.m_prev
    @m_controllerList = controller.m_next  if controller is @m_controllerList
    --@m_controllerCount
    return

  b2World::SetWarmStarting = (flag) ->
    b2World.m_warmStarting = flag
    return

  b2World::SetContinuousPhysics = (flag) ->
    b2World.m_continuousPhysics = flag
    return

  b2World::GetBodyCount = ->
    @m_bodyCount

  b2World::GetJointCount = ->
    @m_jointCount

  b2World::GetContactCount = ->
    @m_contactCount

  b2World::SetGravity = (gravity) ->
    @m_gravity = gravity
    return

  b2World::GetGravity = ->
    @m_gravity

  b2World::GetGroundBody = ->
    @m_groundBody

  b2World::Step = (dt, velocityIterations, positionIterations) ->
    dt = 0  if dt is `undefined`
    velocityIterations = 0  if velocityIterations is `undefined`
    positionIterations = 0  if positionIterations is `undefined`
    if @m_flags & b2World.e_newFixture
      @m_contactManager.FindNewContacts()
      @m_flags &= ~b2World.e_newFixture
    @m_flags |= b2World.e_locked
    step = b2World.s_timestep2
    step.dt = dt
    step.velocityIterations = velocityIterations
    step.positionIterations = positionIterations
    if dt > 0.0
      step.inv_dt = 1.0 / dt
    else
      step.inv_dt = 0.0
    step.dtRatio = @m_inv_dt0 * dt
    step.warmStarting = b2World.m_warmStarting
    @m_contactManager.Collide()
    @Solve step  if step.dt > 0.0
    @SolveTOI step  if b2World.m_continuousPhysics and step.dt > 0.0
    @m_inv_dt0 = step.inv_dt  if step.dt > 0.0
    @m_flags &= ~b2World.e_locked
    return

  b2World::ClearForces = ->
    body = @m_bodyList

    while body
      body.m_force.SetZero()
      body.m_torque = 0.0
      body = body.m_next
    return

  b2World::DrawDebugData = ->
    return  unless @m_debugDraw?
    @m_debugDraw.m_sprite.graphics.clear()
    flags = @m_debugDraw.GetFlags()
    i = 0
    b = undefined
    f = undefined
    s = undefined
    j = undefined
    bp = undefined
    invQ = new b2Vec2
    x1 = new b2Vec2
    x2 = new b2Vec2
    xf = undefined
    b1 = new b2AABB()
    b2 = new b2AABB()
    vs = [
      new b2Vec2()
      new b2Vec2()
      new b2Vec2()
      new b2Vec2()
    ]
    color = new b2Color(0, 0, 0)
    if flags & b2DebugDraw.e_shapeBit
      b = @m_bodyList
      while b
        xf = b.m_xf
        f = b.GetFixtureList()
        while f
          s = f.GetShape()
          if b.IsActive() is false
            color.Set 0.5, 0.5, 0.3
            @DrawShape s, xf, color
          else if b.GetType() is b2Body.b2_staticBody
            color.Set 0.5, 0.9, 0.5
            @DrawShape s, xf, color
          else if b.GetType() is b2Body.b2_kinematicBody
            color.Set 0.5, 0.5, 0.9
            @DrawShape s, xf, color
          else if b.IsAwake() is false
            color.Set 0.6, 0.6, 0.6
            @DrawShape s, xf, color
          else
            color.Set 0.9, 0.7, 0.7
            @DrawShape s, xf, color
          f = f.m_next
        b = b.m_next
    if flags & b2DebugDraw.e_jointBit
      j = @m_jointList
      while j
        @DrawJoint j
        j = j.m_next
    if flags & b2DebugDraw.e_controllerBit
      c = @m_controllerList

      while c
        c.Draw @m_debugDraw
        c = c.m_next
    if flags & b2DebugDraw.e_pairBit
      color.Set 0.3, 0.9, 0.9
      contact = @m_contactManager.m_contactList

      while contact
        fixtureA = contact.GetFixtureA()
        fixtureB = contact.GetFixtureB()
        cA = fixtureA.GetAABB().GetCenter()
        cB = fixtureB.GetAABB().GetCenter()
        @m_debugDraw.DrawSegment cA, cB, color
        contact = contact.GetNext()
    if flags & b2DebugDraw.e_aabbBit
      bp = @m_contactManager.m_broadPhase
      vs = [
        new b2Vec2()
        new b2Vec2()
        new b2Vec2()
        new b2Vec2()
      ]
      b = @m_bodyList
      while b
        continue  if b.IsActive() is false
        f = b.GetFixtureList()
        while f
          aabb = bp.GetFatAABB(f.m_proxy)
          vs[0].Set aabb.lowerBound.x, aabb.lowerBound.y
          vs[1].Set aabb.upperBound.x, aabb.lowerBound.y
          vs[2].Set aabb.upperBound.x, aabb.upperBound.y
          vs[3].Set aabb.lowerBound.x, aabb.upperBound.y
          @m_debugDraw.DrawPolygon vs, 4, color
          f = f.GetNext()
        b = b.GetNext()
    if flags & b2DebugDraw.e_centerOfMassBit
      b = @m_bodyList
      while b
        xf = b2World.s_xf
        xf.R = b.m_xf.R
        xf.position = b.GetWorldCenter()
        @m_debugDraw.DrawTransform xf
        b = b.m_next
    return

  b2World::QueryAABB = (callback, aabb) ->
    WorldQueryWrapper = (proxy) ->
      callback broadPhase.GetUserData(proxy)
    __this = this
    broadPhase = __this.m_contactManager.m_broadPhase
    broadPhase.Query WorldQueryWrapper, aabb
    return

  b2World::QueryShape = (callback, shape, transform) ->
    WorldQueryWrapper = (proxy) ->
      fixture = ((if broadPhase.GetUserData(proxy) instanceof b2Fixture then broadPhase.GetUserData(proxy) else null))
      return callback(fixture)  if b2Shape.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform())
      true
    __this = this
    transform = null  if transform is `undefined`
    unless transform?
      transform = new b2Transform()
      transform.SetIdentity()
    broadPhase = __this.m_contactManager.m_broadPhase
    aabb = new b2AABB()
    shape.ComputeAABB aabb, transform
    broadPhase.Query WorldQueryWrapper, aabb
    return

  b2World::QueryPoint = (callback, p) ->
    WorldQueryWrapper = (proxy) ->
      fixture = ((if broadPhase.GetUserData(proxy) instanceof b2Fixture then broadPhase.GetUserData(proxy) else null))
      return callback(fixture)  if fixture.TestPoint(p)
      true
    __this = this
    broadPhase = __this.m_contactManager.m_broadPhase
    aabb = new b2AABB()
    aabb.lowerBound.Set p.x - b2Settings.b2_linearSlop, p.y - b2Settings.b2_linearSlop
    aabb.upperBound.Set p.x + b2Settings.b2_linearSlop, p.y + b2Settings.b2_linearSlop
    broadPhase.Query WorldQueryWrapper, aabb
    return

  b2World::RayCast = (callback, point1, point2) ->
    RayCastWrapper = (input, proxy) ->
      userData = broadPhase.GetUserData(proxy)
      fixture = ((if userData instanceof b2Fixture then userData else null))
      hit = fixture.RayCast(output, input)
      if hit
        fraction = output.fraction
        point = new b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y)
        return callback(fixture, point, output.normal, fraction)
      input.maxFraction
    __this = this
    broadPhase = __this.m_contactManager.m_broadPhase
    output = new b2RayCastOutput
    input = new b2RayCastInput(point1, point2)
    broadPhase.RayCast RayCastWrapper, input
    return

  b2World::RayCastOne = (point1, point2) ->
    RayCastOneWrapper = (fixture, point, normal, fraction) ->
      fraction = 0  if fraction is `undefined`
      result = fixture
      fraction
    __this = this
    result = undefined
    __this.RayCast RayCastOneWrapper, point1, point2
    result

  b2World::RayCastAll = (point1, point2) ->
    RayCastAllWrapper = (fixture, point, normal, fraction) ->
      fraction = 0  if fraction is `undefined`
      result[result.length] = fixture
      1
    __this = this
    result = new Vector()
    __this.RayCast RayCastAllWrapper, point1, point2
    result

  b2World::GetBodyList = ->
    @m_bodyList

  b2World::GetJointList = ->
    @m_jointList

  b2World::GetContactList = ->
    @m_contactList

  b2World::IsLocked = ->
    (@m_flags & b2World.e_locked) > 0

  b2World::Solve = (step) ->
    b = undefined
    controller = @m_controllerList

    while controller
      controller.Step step
      controller = controller.m_next
    island = @m_island
    island.Initialize @m_bodyCount, @m_contactCount, @m_jointCount, null, @m_contactManager.m_contactListener, @m_contactSolver
    b = @m_bodyList
    while b
      b.m_flags &= ~b2Body.e_islandFlag
      b = b.m_next
    c = @m_contactList

    while c
      c.m_flags &= ~b2Contact.e_islandFlag
      c = c.m_next
    j = @m_jointList

    while j
      j.m_islandFlag = false
      j = j.m_next
    stackSize = parseInt(@m_bodyCount)
    stack = @s_stack
    seed = @m_bodyList

    while seed
      continue  if seed.m_flags & b2Body.e_islandFlag
      continue  if seed.IsAwake() is false or seed.IsActive() is false
      continue  if seed.GetType() is b2Body.b2_staticBody
      island.Clear()
      stackCount = 0
      stack[stackCount++] = seed
      seed.m_flags |= b2Body.e_islandFlag
      while stackCount > 0
        b = stack[--stackCount]
        island.AddBody b
        b.SetAwake true  if b.IsAwake() is false
        continue  if b.GetType() is b2Body.b2_staticBody
        other = undefined
        ce = b.m_contactList

        while ce
          continue  if ce.contact.m_flags & b2Contact.e_islandFlag
          continue  if ce.contact.IsSensor() is true or ce.contact.IsEnabled() is false or ce.contact.IsTouching() is false
          island.AddContact ce.contact
          ce.contact.m_flags |= b2Contact.e_islandFlag
          other = ce.other
          continue  if other.m_flags & b2Body.e_islandFlag
          stack[stackCount++] = other
          other.m_flags |= b2Body.e_islandFlag
          ce = ce.next
        jn = b.m_jointList

        while jn
          continue  if jn.joint.m_islandFlag is true
          other = jn.other
          continue  if other.IsActive() is false
          island.AddJoint jn.joint
          jn.joint.m_islandFlag = true
          continue  if other.m_flags & b2Body.e_islandFlag
          stack[stackCount++] = other
          other.m_flags |= b2Body.e_islandFlag
          jn = jn.next
      island.Solve step, @m_gravity, @m_allowSleep
      i = 0

      while i < island.m_bodyCount
        b = island.m_bodies[i]
        b.m_flags &= ~b2Body.e_islandFlag  if b.GetType() is b2Body.b2_staticBody
        ++i
      seed = seed.m_next
    i = 0
    while i < stack.length
      break  unless stack[i]
      stack[i] = null
      ++i
    b = @m_bodyList
    while b
      continue  if b.IsAwake() is false or b.IsActive() is false
      continue  if b.GetType() is b2Body.b2_staticBody
      b.SynchronizeFixtures()
      b = b.m_next
    @m_contactManager.FindNewContacts()
    return

  b2World::SolveTOI = (step) ->
    b = undefined
    fA = undefined
    fB = undefined
    bA = undefined
    bB = undefined
    cEdge = undefined
    j = undefined
    island = @m_island
    island.Initialize @m_bodyCount, b2Settings.b2_maxTOIContactsPerIsland, b2Settings.b2_maxTOIJointsPerIsland, null, @m_contactManager.m_contactListener, @m_contactSolver
    queue = b2World.s_queue
    b = @m_bodyList
    while b
      b.m_flags &= ~b2Body.e_islandFlag
      b.m_sweep.t0 = 0.0
      b = b.m_next
    c = undefined
    c = @m_contactList
    while c
      c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
      c = c.m_next
    j = @m_jointList
    while j
      j.m_islandFlag = false
      j = j.m_next
    loop
      minContact = null
      minTOI = 1.0
      c = @m_contactList
      while c
        continue  if c.IsSensor() is true or c.IsEnabled() is false or c.IsContinuous() is false
        toi = 1.0
        if c.m_flags & b2Contact.e_toiFlag
          toi = c.m_toi
        else
          fA = c.m_fixtureA
          fB = c.m_fixtureB
          bA = fA.m_body
          bB = fB.m_body
          continue  if (bA.GetType() isnt b2Body.b2_dynamicBody or bA.IsAwake() is false) and (bB.GetType() isnt b2Body.b2_dynamicBody or bB.IsAwake() is false)
          t0 = bA.m_sweep.t0
          if bA.m_sweep.t0 < bB.m_sweep.t0
            t0 = bB.m_sweep.t0
            bA.m_sweep.Advance t0
          else if bB.m_sweep.t0 < bA.m_sweep.t0
            t0 = bA.m_sweep.t0
            bB.m_sweep.Advance t0
          toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep)
          b2Settings.b2Assert 0.0 <= toi and toi <= 1.0
          if toi > 0.0 and toi < 1.0
            toi = (1.0 - toi) * t0 + toi
            toi = 1  if toi > 1
          c.m_toi = toi
          c.m_flags |= b2Contact.e_toiFlag
        if Number.MIN_VALUE < toi and toi < minTOI
          minContact = c
          minTOI = toi
        c = c.m_next
      break  if not minContact? or 1.0 - 100.0 * Number.MIN_VALUE < minTOI
      fA = minContact.m_fixtureA
      fB = minContact.m_fixtureB
      bA = fA.m_body
      bB = fB.m_body
      b2World.s_backupA.Set bA.m_sweep
      b2World.s_backupB.Set bB.m_sweep
      bA.Advance minTOI
      bB.Advance minTOI
      minContact.Update @m_contactManager.m_contactListener
      minContact.m_flags &= ~b2Contact.e_toiFlag
      if minContact.IsSensor() is true or minContact.IsEnabled() is false
        bA.m_sweep.Set b2World.s_backupA
        bB.m_sweep.Set b2World.s_backupB
        bA.SynchronizeTransform()
        bB.SynchronizeTransform()
        continue
      continue  if minContact.IsTouching() is false
      seed = bA
      seed = bB  unless seed.GetType() is b2Body.b2_dynamicBody
      island.Clear()
      queueStart = 0
      queueSize = 0
      queue[queueStart + queueSize++] = seed
      seed.m_flags |= b2Body.e_islandFlag
      while queueSize > 0
        b = queue[queueStart++]
        --queueSize
        island.AddBody b
        b.SetAwake true  if b.IsAwake() is false
        continue  unless b.GetType() is b2Body.b2_dynamicBody
        cEdge = b.m_contactList
        while cEdge
          break  if island.m_contactCount is island.m_contactCapacity
          continue  if cEdge.contact.m_flags & b2Contact.e_islandFlag
          continue  if cEdge.contact.IsSensor() is true or cEdge.contact.IsEnabled() is false or cEdge.contact.IsTouching() is false
          island.AddContact cEdge.contact
          cEdge.contact.m_flags |= b2Contact.e_islandFlag
          other = cEdge.other
          continue  if other.m_flags & b2Body.e_islandFlag
          unless other.GetType() is b2Body.b2_staticBody
            other.Advance minTOI
            other.SetAwake true
          queue[queueStart + queueSize] = other
          ++queueSize
          other.m_flags |= b2Body.e_islandFlag
          cEdge = cEdge.next
        jEdge = b.m_jointList

        while jEdge
          continue  if island.m_jointCount is island.m_jointCapacity
          continue  if jEdge.joint.m_islandFlag is true
          other = jEdge.other
          continue  if other.IsActive() is false
          island.AddJoint jEdge.joint
          jEdge.joint.m_islandFlag = true
          continue  if other.m_flags & b2Body.e_islandFlag
          unless other.GetType() is b2Body.b2_staticBody
            other.Advance minTOI
            other.SetAwake true
          queue[queueStart + queueSize] = other
          ++queueSize
          other.m_flags |= b2Body.e_islandFlag
          jEdge = jEdge.next
      subStep = b2World.s_timestep
      subStep.warmStarting = false
      subStep.dt = (1.0 - minTOI) * step.dt
      subStep.inv_dt = 1.0 / subStep.dt
      subStep.dtRatio = 0.0
      subStep.velocityIterations = step.velocityIterations
      subStep.positionIterations = step.positionIterations
      island.SolveTOI subStep
      i = 0
      i = 0
      while i < island.m_bodyCount
        b = island.m_bodies[i]
        b.m_flags &= ~b2Body.e_islandFlag
        continue  if b.IsAwake() is false
        continue  unless b.GetType() is b2Body.b2_dynamicBody
        b.SynchronizeFixtures()
        cEdge = b.m_contactList
        while cEdge
          cEdge.contact.m_flags &= ~b2Contact.e_toiFlag
          cEdge = cEdge.next
        ++i
      i = 0
      while i < island.m_contactCount
        c = island.m_contacts[i]
        c.m_flags &= ~(b2Contact.e_toiFlag | b2Contact.e_islandFlag)
        ++i
      i = 0
      while i < island.m_jointCount
        j = island.m_joints[i]
        j.m_islandFlag = false
        ++i
      @m_contactManager.FindNewContacts()
    return

  b2World::DrawJoint = (joint) ->
    b1 = joint.GetBodyA()
    b2 = joint.GetBodyB()
    xf1 = b1.m_xf
    xf2 = b2.m_xf
    x1 = xf1.position
    x2 = xf2.position
    p1 = joint.GetAnchorA()
    p2 = joint.GetAnchorB()
    color = b2World.s_jointColor
    switch joint.m_type
      when b2Joint.e_distanceJoint
        @m_debugDraw.DrawSegment p1, p2, color
      when b2Joint.e_pulleyJoint
        pulley = ((if joint instanceof b2PulleyJoint then joint else null))
        s1 = pulley.GetGroundAnchorA()
        s2 = pulley.GetGroundAnchorB()
        @m_debugDraw.DrawSegment s1, p1, color
        @m_debugDraw.DrawSegment s2, p2, color
        @m_debugDraw.DrawSegment s1, s2, color
      when b2Joint.e_mouseJoint
        @m_debugDraw.DrawSegment p1, p2, color
      else
        @m_debugDraw.DrawSegment x1, p1, color  unless b1 is @m_groundBody
        @m_debugDraw.DrawSegment p1, p2, color
        @m_debugDraw.DrawSegment x2, p2, color  unless b2 is @m_groundBody
    return

  b2World::DrawShape = (shape, xf, color) ->
    switch shape.m_type
      when b2Shape.e_circleShape
        circle = ((if shape instanceof b2CircleShape then shape else null))
        center = b2Math.MulX(xf, circle.m_p)
        radius = circle.m_radius
        axis = xf.R.col1
        @m_debugDraw.DrawSolidCircle center, radius, axis, color
      when b2Shape.e_polygonShape
        i = 0
        poly = ((if shape instanceof b2PolygonShape then shape else null))
        vertexCount = parseInt(poly.GetVertexCount())
        localVertices = poly.GetVertices()
        vertices = new Vector(vertexCount)
        i = 0
        while i < vertexCount
          vertices[i] = b2Math.MulX(xf, localVertices[i])
          ++i
        @m_debugDraw.DrawSolidPolygon vertices, vertexCount, color
      when b2Shape.e_edgeShape
        edge = ((if shape instanceof b2EdgeShape then shape else null))
        @m_debugDraw.DrawSegment b2Math.MulX(xf, edge.GetVertex1()), b2Math.MulX(xf, edge.GetVertex2()), color

  Box2D.postDefs.push ->
    Box2D.Dynamics.b2World.s_timestep2 = new b2TimeStep()
    Box2D.Dynamics.b2World.s_xf = new b2Transform()
    Box2D.Dynamics.b2World.s_backupA = new b2Sweep()
    Box2D.Dynamics.b2World.s_backupB = new b2Sweep()
    Box2D.Dynamics.b2World.s_timestep = new b2TimeStep()
    Box2D.Dynamics.b2World.s_queue = new Vector()
    Box2D.Dynamics.b2World.s_jointColor = new b2Color(0.5, 0.8, 0.8)
    Box2D.Dynamics.b2World.e_newFixture = 0x0001
    Box2D.Dynamics.b2World.e_locked = 0x0002
    return

  return
)()
